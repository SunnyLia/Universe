<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - geometry - text</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
</head>

<body>
	<script src="js/three.js"></script>
	<script type="module">
		THREE.Cache.enabled = true;
		var textMesh1, textMesh2; //物体（网格）1，物体（网格）2 倒影
		var textGeo = "";//创建一个全局的文本几何体
		var firstLetter = true; //清空文本
		var text = "three.js",
			height = 20,
			size = 70,
			bevelEnabled = true, //是否开启斜角
			font = undefined;
		var mirror = false; //是否创建物体（网格）2，其实就是倒影
		var targetRotation = 0;
		var targetRotationOnPointerDown = 0;
		var pointerX = 0;
		var pointerXOnPointerDown = 0;
		var windowHalfX = window.innerWidth / 2;
		var fontIndex = 1;

		// *创建(透视)摄像机
		var camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 1500);
		camera.position.set(0, 300, 700);


		// *创建场景
		var scene = new THREE.Scene();
		// 给场景添加背景及雾化
		scene.background = new THREE.Color('#9083d6');
		scene.fog = new THREE.Fog('#6ad280', 250, 1400);


		// 添加灯光（平行光）
		var dirLight = new THREE.DirectionalLight('#ffffff', 0.125);
		dirLight.position.set(0, 0, 1).normalize();
		scene.add(dirLight);
		// 添加灯光（光源），从一个点向各个方向发射的光源
		var pointLight = new THREE.PointLight('#e44747', 1.5);
		pointLight.position.set(0, 100, 80);
		scene.add(pointLight);


		// 创建并添加物体（组）
		var group = new THREE.Group();
		group.position.y = 100;
		scene.add(group);

		// 创建并添加物体（网格）
		var plane = new THREE.Mesh(
			// 几何体（平面缓冲几何体）
			new THREE.PlaneBufferGeometry(10000, 10000),
			// 材质（基础网格材质）
			new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true })
		);
		plane.position.y = 100;
		plane.rotation.x = - Math.PI / 2;
		scene.add(plane);


		// *创建WebGL渲染器
		var renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio); //设置设备像素比
		renderer.setSize(window.innerWidth, window.innerHeight); //设置大小

		document.body.appendChild(renderer.domElement);


		// 加载并设置字体
		var loader = new THREE.FontLoader();
		loader.load('fonts/optimer_bold.typeface.json', function (response) {
			font = response;
			refreshText();
		});



		// 创建一个数学库（三维空间点）
		var cameraTarget = new THREE.Vector3(0, 150, 0);

		// 添加循环动画
		animate();
		function animate() {
			console.log('animate');
			requestAnimationFrame(animate);
			group.rotation.y += (targetRotation - group.rotation.y) * 0.05;
			camera.lookAt(cameraTarget); //跟踪目标，让物体永远在屏幕的中央
			renderer.clear();
			renderer.render(scene, camera);
		}


		// 材质（Phong网格材质）
		var materials = [
			new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true }), // front
			new THREE.MeshPhongMaterial({ color: 0xffffff }) // side
		];

		function createText() {

			// 创建几何体（文本几何体）
			textGeo = new THREE.TextGeometry("three.js", {
				font: font, //字体
				size: 70, //大小
				height: 20, //厚度
				curveSegments: 4, //文本上曲线上点的数量
				bevelThickness: 2, //文本上斜角的深度
				bevelSize: 1.5, //斜角与原始文本轮廓之间的延伸距离
				bevelEnabled: bevelEnabled  //是否开启斜角
			});

			textGeo.computeBoundingBox(); //计算当前盒子范围,盒的最小和最大顶点 
			textGeo.computeVertexNormals(); //设置模型顶点平滑（让物体切面更光滑）

			// 创建数学库（三角形）
			var triangle = new THREE.Triangle();


			if (!bevelEnabled) {
				// 这段的作用是，使物体更立体
				var triangleAreaHeuristics = 0.1 * (height * size);
				for (var i = 0; i < textGeo.faces.length; i++) {
					var face = textGeo.faces[i];
					if (face.materialIndex == 1) {
						for (var j = 0; j < face.vertexNormals.length; j++) {
							face.vertexNormals[j].z = 0;
							face.vertexNormals[j].normalize();
						}
						var va = textGeo.vertices[face.a];
						var vb = textGeo.vertices[face.b];
						var vc = textGeo.vertices[face.c];
						var s = triangle.set(va, vb, vc).getArea();
						if (s > triangleAreaHeuristics) {
							for (var j = 0; j < face.vertexNormals.length; j++) {
								face.vertexNormals[j].copy(face.normal);
							}
						}
					}
				}
			}


			// 创建一个几何体，将文本几何体转换
			textGeo = new THREE.BufferGeometry().fromGeometry(textGeo);

			var centerOffset = - 0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
			// 创建物体（网格）
			textMesh1 = new THREE.Mesh(textGeo, materials);
			textMesh1.position.x = centerOffset;
			textMesh1.position.y = 30;
			textMesh1.position.z = 0;
			textMesh1.rotation.x = 0;
			textMesh1.rotation.y = Math.PI * 2;
			group.add(textMesh1);

			if (mirror) {
				textMesh2 = new THREE.Mesh(textGeo, materials);
				textMesh2.position.x = centerOffset;
				textMesh2.position.y = -30;
				textMesh2.position.z = height;
				textMesh2.rotation.x = Math.PI;
				textMesh2.rotation.y = Math.PI * 2;
				group.add(textMesh2);
			}
		}

		function refreshText() {
			group.remove(textMesh1);
			if (mirror) group.remove(textMesh2);
			if (!text) return;
			createText();
		}


	</script>

</body>

</html>