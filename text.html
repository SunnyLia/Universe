<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - geometry - text</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
</head>

<body>
	<script src="js/three.js"></script>
	<script type="module">


		THREE.Cache.enabled = true;

		var textMesh1, textMesh2;
		var textGeo = "";//创建一个全局的文本几何体
		var firstLetter = true;

		var text = "three.js",
			height = 20,
			size = 70,
			hover = 30,
			bevelEnabled = true, //是否开启斜角
			font = undefined;
		var mirror = true;

		var targetRotation = 0;
		var targetRotationOnPointerDown = 0;

		var pointerX = 0;
		var pointerXOnPointerDown = 0;

		var windowHalfX = window.innerWidth / 2;

		var fontIndex = 1;




		// 创建(透视)摄像机
		var camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 1500);
		camera.position.set(0, 400, 700);

		// 创建一个数学库（三维空间点）
		var cameraTarget = new THREE.Vector3(0, 150, 0);


		// 创建场景
		var scene = new THREE.Scene();
		// 给场景添加背景及雾化
		scene.background = new THREE.Color(0x000000);
		scene.fog = new THREE.Fog(0x000000, 250, 1400);


		// 添加灯光（平行光）
		var dirLight = new THREE.DirectionalLight(0xffffff, 0.125);
		dirLight.position.set(0, 0, 1).normalize();
		scene.add(dirLight);
		// 添加灯光（光源），从一个点向各个方向发射的光源
		var pointLight = new THREE.PointLight(0xffffff, 1.5);
		pointLight.position.set(0, 100, 90);
		scene.add(pointLight);


		// 材质（Phong网格材质）
		var materials = [
			new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true }), // front
			new THREE.MeshPhongMaterial({ color: 0xffffff }) // side
		];


		// 创建并添加物体（组）
		var group = new THREE.Group();
		group.position.y = 100;
		scene.add(group);


		// 加载并设置字体
		var loader = new THREE.FontLoader();
		loader.load('fonts/optimer_bold.typeface.json', function (response) {
			font = response;
			refreshText();
		});


		// 创建并添加物体（网格）
		var plane = new THREE.Mesh(
			// 几何体（平面缓冲几何体）
			new THREE.PlaneBufferGeometry(10000, 10000),
			// 材质（基础网格材质）
			new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true })
		);
		plane.position.y = 100;
		plane.rotation.x = - Math.PI / 2;
		scene.add(plane);


		// 创建WebGL渲染器
		var renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio); //设置设备像素比
		renderer.setSize(window.innerWidth, window.innerHeight); //设置大小


		// 创建一个容器div
		var container = document.createElement('div');
		document.body.appendChild(container);
		container.appendChild(renderer.domElement);


		// 添加事件
		container.style.touchAction = 'none';
		// Pointer将鼠标（Mouse）、触摸（touch)和触控笔（pen）三种事件整合为统一的API
		container.addEventListener('pointerdown', onPointerDown, false);
		document.addEventListener('keypress', onDocumentKeyPress, false);
		document.addEventListener('keydown', onDocumentKeyDown, false);
		window.addEventListener('resize', onWindowResize, false);


		// 添加循环动画
		animate();
		function animate() {
			requestAnimationFrame(animate);
			group.rotation.y += (targetRotation - group.rotation.y) * 0.05;
			camera.lookAt(cameraTarget); //跟踪目标，让物体永远在屏幕的中央
			renderer.clear();
			renderer.render(scene, camera);
		}


		function createText() {

			// 创建几何体（文本几何体）
			textGeo = new THREE.TextGeometry("three.js", {
				font: font,
				size: 70,
				height: 20,
				curveSegments: 4,
				bevelThickness: 2,
				bevelSize: 1.5,
				bevelEnabled: bevelEnabled
			});

			textGeo.computeBoundingBox(); //计算当前盒子范围,盒的最小和最大顶点 
			textGeo.computeVertexNormals(); //设置模型顶点平滑

			// 创建数学库（三角形）
			var triangle = new THREE.Triangle();

			if (!bevelEnabled) {

				var triangleAreaHeuristics = 0.1 * (height * size);

				for (var i = 0; i < textGeo.faces.length; i++) {

					var face = textGeo.faces[i];

					if (face.materialIndex == 1) {

						for (var j = 0; j < face.vertexNormals.length; j++) {

							face.vertexNormals[j].z = 0;
							face.vertexNormals[j].normalize();

						}

						var va = textGeo.vertices[face.a];
						var vb = textGeo.vertices[face.b];
						var vc = textGeo.vertices[face.c];

						var s = triangle.set(va, vb, vc).getArea();

						if (s > triangleAreaHeuristics) {

							for (var j = 0; j < face.vertexNormals.length; j++) {

								face.vertexNormals[j].copy(face.normal);

							}

						}

					}

				}

			}

			var centerOffset = - 0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);

			textGeo = new THREE.BufferGeometry().fromGeometry(textGeo);

			textMesh1 = new THREE.Mesh(textGeo, materials);

			textMesh1.position.x = centerOffset;
			textMesh1.position.y = hover;
			textMesh1.position.z = 0;

			textMesh1.rotation.x = 0;
			textMesh1.rotation.y = Math.PI * 2;

			group.add(textMesh1);

			if (mirror) {

				textMesh2 = new THREE.Mesh(textGeo, materials);

				textMesh2.position.x = centerOffset;
				textMesh2.position.y = - hover;
				textMesh2.position.z = height;

				textMesh2.rotation.x = Math.PI;
				textMesh2.rotation.y = Math.PI * 2;

				group.add(textMesh2);

			}

		}

		function refreshText() {
			group.remove(textMesh1);
			if (mirror) group.remove(textMesh2);
			if (!text) return;
			createText();
		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function onDocumentKeyDown(event) {

			if (firstLetter) {

				firstLetter = false;
				text = "";

			}
			console.log(111111111);

			var keyCode = event.keyCode;

			// backspace

			if (keyCode == 8) {

				event.preventDefault();

				text = text.substring(0, text.length - 1);
				refreshText();

				return false;

			}

		}

		function onDocumentKeyPress(event) {

			var keyCode = event.which;

			// backspace

			if (keyCode == 8) {

				event.preventDefault();

			} else {

				var ch = String.fromCharCode(keyCode);
				text += ch;

				refreshText();

			}

		}


		function onPointerDown(event) {

			if (event.isPrimary === false) return;

			pointerXOnPointerDown = event.clientX - windowHalfX;
			targetRotationOnPointerDown = targetRotation;

			document.addEventListener('pointermove', onPointerMove, false);
			document.addEventListener('pointerup', onPointerUp, false);

		}

		function onPointerMove(event) {

			if (event.isPrimary === false) return;

			pointerX = event.clientX - windowHalfX;

			targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;

		}

		function onPointerUp() {

			if (event.isPrimary === false) return;

			document.removeEventListener('pointermove', onPointerMove);
			document.removeEventListener('pointerup', onPointerUp);

		}


	</script>

</body>

</html>